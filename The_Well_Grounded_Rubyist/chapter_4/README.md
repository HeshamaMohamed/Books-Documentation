
# Chapter 4: Modules and program organization

## Topics covered in this chapter:
- Modules, up close and in detail.
- Similarities and differences between modules and classes (both can bundle methods and constants together, but modules can't be instantiated).
- Examples of how you might use modules to express the design of a program.
- An object's-eye view of the process of finding and executing a method in response to a message, or  handling failure with method_missing in cases where the message doesn't match a method.
- How to next classes and modules inside each other, with the benefit of  keeping namespaces separate and clear.



## Personal thoughts
- we could achieve the purpose of 'multi-inheritance' through modules since we can import multiple modules into our classes

- I liked the flexibility of the module concept. I could see the potential and possibilities proposed by keywords such as include, prepend and extend.

- After getting exposed to the Module::Class concept, I am starting to understand how flexible Ruby is.  
    How important the naming convention is.  It is good to get some sense about whether this constant is probably a class or a module.